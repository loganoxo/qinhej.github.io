<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script></script><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"ce3881c3"}),daovoice("update")</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="排序,"><link rel="alternate" href="/atom.xml" title="秦贺的博客" type="application/atom+xml"><meta name="description" content="1、直接插入排序  我们经常会到这样一类排序问题："><meta name="keywords" content="排序"><meta property="og:type" content="article"><meta property="og:title" content="Java常用的八种排序算法与代码实现"><meta property="og:url" content="http://yoursite.com/2018/08/01/java/java/Java常用的八种排序算法与代码实现/index.html"><meta property="og:site_name" content="秦贺的博客"><meta property="og:description" content="1、直接插入排序  我们经常会到这样一类排序问题："><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://img-blog.csdn.net/20180801162925644?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><meta property="og:image" content="https://img-blog.csdn.net/20180801163251875?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><meta property="og:image" content="https://img-blog.csdn.net/20180801163457914?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><meta property="og:image" content="https://img-blog.csdn.net/20180801163619782?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><meta property="og:image" content="https://img-blog.csdn.net/20180801163822502?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><meta property="og:image" content="https://img-blog.csdn.net/20180801163841272?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><meta property="og:image" content="https://img-blog.csdn.net/20180801163954573?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><meta property="og:image" content="https://img-blog.csdn.net/20180801164250720?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><meta property="og:image" content="https://img-blog.csdn.net/20180801164323823?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><meta property="og:updated_time" content="2018-08-01T09:41:19.460Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java常用的八种排序算法与代码实现"><meta name="twitter:description" content="1、直接插入排序  我们经常会到这样一类排序问题："><meta name="twitter:image" content="https://img-blog.csdn.net/20180801162925644?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"QinHe"},algolia:{applicationID:"FNMQKMRSYO",apiKey:"1c7c5f8f7f7c31886eede32da3f67ed3",indexName:"hexo",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2018/08/01/java/java/Java常用的八种排序算法与代码实现/"><title>Java常用的八种排序算法与代码实现 | 秦贺的博客</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?df2f085ca1e73bf7063afbe80560f855";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/qinheJ" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff;color:#151513;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg><span style="color:#000;font-weight:700;position:absolute;top:0;border:0;right:0"><br><br>&emsp;Fork me on GitHub&emsp;</span></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">秦贺的博客</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/01/java/java/Java常用的八种排序算法与代码实现/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="QinHe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/portrait.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="秦贺的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java常用的八种排序算法与代码实现</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-01T17:41:19+08:00">2018-08-01</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">3,071</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">13</span></div></div></header><div class="post-body" itemprop="articleBody"><ul><li>1、直接插入排序</li></ul><p>我们经常会到这样一类排序问题：<a id="more"></a>把新的数据插入到已经排好的数据列中。将第一个数和第二个数排序，然后构成一个有序序列将第三个数插入进去，构成一个新的有序序列。对第四个数、第五个数……直到最后一个数，重复第二步。如题所示：</p><p><img src="https://img-blog.csdn.net/20180801162925644?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>直接插入排序（Straight Insertion Sorting）的基本思想：在要排序的一组数中，假设前面(n-1) [n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p><p>代码实现：</p><p>首先设定插入次数，即循环次数，for(int i=1;i&lt;length;i++)，1个数的那次不用插入。<br>设定插入数和得到已经排好序列的最后一个数的位数。insertNum和j=i-1。<br>从最后一个数开始向前循环，如果插入数小于当前数，就将当前数向后移动一位。<br>将当前数放置到空着的位置，即j+1。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> [] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=a.length;<span class="comment">//单独把数组长度拿出来，提高效率</span></span><br><span class="line">       <span class="keyword">int</span> insertNum;<span class="comment">//要插入的数</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;<span class="comment">//因为第一次不用，所以从1开始</span></span><br><span class="line">            insertNum=a[i];</span><br><span class="line">           <span class="keyword">int</span> j=i-<span class="number">1</span>;<span class="comment">//序列元素个数</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;a[j]&gt;insertNum)&#123;<span class="comment">//从后往前循环，将大于insertNum的数向后移动</span></span><br><span class="line">                a[j+<span class="number">1</span>]=a[j];<span class="comment">//元素向后移动</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+<span class="number">1</span>]=insertNum;<span class="comment">//找到位置，插入当前元素</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、希尔排序</li></ul><p>针对直接插入排序的下效率问题，有人对次进行了改进与升级，这就是现在的希尔排序。希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><p>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率<br>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位<br>如图所示：</p><p><img src="https://img-blog.csdn.net/20180801163251875?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>对于直接插入排序问题，数据量巨大时。<br>将数的个数设为n，取奇数k=n/2，将下标差值为k的数分为一组，构成有序序列。<br>再取k=k/2 ，将下标差值为k的书分为一组，构成有序序列。<br>重复第二步，直到k=1执行简单插入排序。</p><p>代码实现：</p><p>首先确定分的组数。<br>然后对组中元素进行插入排序。<br>然后将length/2，重复1,2步，直到length=0为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sheelSort</span><span class="params">(<span class="keyword">int</span> [] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=a.length;<span class="comment">//单独把数组长度拿出来，提高效率</span></span><br><span class="line">        <span class="keyword">while</span>(len!=<span class="number">0</span>)&#123;</span><br><span class="line">            len=len/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;<span class="comment">//分组</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+len;j&lt;a.length;j+=len)&#123;<span class="comment">//元素从第二个开始</span></span><br><span class="line">                    <span class="keyword">int</span> k=j-len;<span class="comment">//k为有序序列最后一位的位数</span></span><br><span class="line">                    <span class="keyword">int</span> temp=a[j];<span class="comment">//要插入的元素</span></span><br><span class="line">                    <span class="comment">/*for(;k&gt;=0&amp;&amp;temp&lt;a[k];k-=len)&#123;</span></span><br><span class="line"><span class="comment">                        a[k+len]=a[k];</span></span><br><span class="line"><span class="comment">                    &#125;*/</span></span><br><span class="line">                    <span class="keyword">while</span>(k&gt;=<span class="number">0</span>&amp;&amp;temp&lt;a[k])&#123;<span class="comment">//从后往前遍历</span></span><br><span class="line">                        a[k+len]=a[k];</span><br><span class="line">                        k-=len;<span class="comment">//向后移动len位</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    a[k+len]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、简单选择排序<br>常用于取序列中最大最小的几个数时。<br>(如果每次比较都交换，那么就是交换排序；如果每次比较完一个循环再交换，就是简单选择排序。)<br>遍历整个序列，将最小的数放在最前面。<br>遍历剩下的序列，将最小的数放在最前面。<br>重复第二步，直到只剩下一个数。</li></ul><p><img src="https://img-blog.csdn.net/20180801163457914?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>代码实现：</p><p>首先确定循环次数，并且记住当前数字和当前位置。<br>将当前位置后面所有的数与当前数字进行对比，小数赋值给key，并记住小数的位置。<br>比对完成后，将最小的值与第一个数的值交换。<br>重复2、3步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[]a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;<span class="comment">//循环次数</span></span><br><span class="line">            <span class="keyword">int</span> value=a[i];</span><br><span class="line">            <span class="keyword">int</span> position=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;<span class="comment">//找到最小的值和位置</span></span><br><span class="line">                <span class="keyword">if</span>(a[j]&lt;value)&#123;</span><br><span class="line">                    value=a[j];</span><br><span class="line">                    position=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[position]=a[i];<span class="comment">//进行交换</span></span><br><span class="line">            a[i]=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>4、堆排序<br>对简单选择排序的优化。<br>将序列构建成大顶堆。<br>将根节点与最后一个节点交换，然后断开最后一个节点。<br>重复第一、二步，直到所有节点断开。</p><p><img src="https://img-blog.csdn.net/20180801163619782?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p></li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">           <span class="keyword">int</span> len=a.length;</span><br><span class="line">           <span class="comment">//循环建堆  </span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">               <span class="comment">//建堆  </span></span><br><span class="line">               buildMaxHeap(a,len-<span class="number">1</span>-i);</span><br><span class="line">               <span class="comment">//交换堆顶和最后一个元素  </span></span><br><span class="line">               swap(a,<span class="number">0</span>,len-<span class="number">1</span>-i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">//交换方法</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> tmp=data[i];</span><br><span class="line">           data[i]=data[j];</span><br><span class="line">           data[j]=tmp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//对data数组从0到lastIndex建大顶堆  </span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> lastIndex)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//从lastIndex处节点（最后一个节点）的父节点开始  </span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=(lastIndex-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">               <span class="comment">//k保存正在判断的节点  </span></span><br><span class="line">               <span class="keyword">int</span> k=i;</span><br><span class="line">               <span class="comment">//如果当前k节点的子节点存在  </span></span><br><span class="line">               <span class="keyword">while</span>(k*<span class="number">2</span>+<span class="number">1</span>&lt;=lastIndex)&#123;</span><br><span class="line">                   <span class="comment">//k节点的左子节点的索引  </span></span><br><span class="line">                   <span class="keyword">int</span> biggerIndex=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                   <span class="comment">//如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在  </span></span><br><span class="line">                   <span class="keyword">if</span>(biggerIndex&lt;lastIndex)&#123;</span><br><span class="line">                       <span class="comment">//若果右子节点的值较大  </span></span><br><span class="line">                       <span class="keyword">if</span>(data[biggerIndex]&lt;data[biggerIndex+<span class="number">1</span>])&#123;</span><br><span class="line">                           <span class="comment">//biggerIndex总是记录较大子节点的索引  </span></span><br><span class="line">                           biggerIndex++;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//如果k节点的值小于其较大的子节点的值  </span></span><br><span class="line">                   <span class="keyword">if</span>(data[k]&lt;data[biggerIndex])&#123;</span><br><span class="line">                       <span class="comment">//交换他们  </span></span><br><span class="line">                       swap(data,k,biggerIndex);</span><br><span class="line">                       <span class="comment">//将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值  </span></span><br><span class="line">                       k=biggerIndex;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><ul><li>5、冒泡排序<br>很简单，用到的很少，据了解，面试的时候问的比较多！<br>将序列中所有元素两两比较，将最大的放在最后面。<br>将剩余序列中所有元素两两比较，将最大的放在最后面。<br>重复第二步，直到只剩下一个数。</li></ul><p><img src="https://img-blog.csdn.net/20180801163822502?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>代码实现：</p><p>设置循环次数。<br>设置开始比较的位数，和结束的位数。<br>两两比较，将最小的放到前面去。<br>重复2、3步，直到循环次数完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> []a)</span></span>&#123;</span><br><span class="line">          <span class="keyword">int</span> len=a.length;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len-i-<span class="number">1</span>;j++)&#123;<span class="comment">//注意第二重循环的条件</span></span><br><span class="line">                  <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                      <span class="keyword">int</span> temp=a[j];</span><br><span class="line">                      a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">                      a[j+<span class="number">1</span>]=temp;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>6.快速排序<br>要求时间最快时。<br>选择第一个数为p，小于p的数放在左边，大于p的数放在右边。<br>递归的将p左边和右边的数都按照第一步进行，直到不能递归。</p><p> <img src="https://img-blog.csdn.net/20180801163841272?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(start&lt;end)&#123;</span><br><span class="line">              <span class="keyword">int</span> baseNum=a[start];<span class="comment">//选基准值</span></span><br><span class="line">              <span class="keyword">int</span> midNum;<span class="comment">//记录中间值</span></span><br><span class="line">              <span class="keyword">int</span> i=start;</span><br><span class="line">              <span class="keyword">int</span> j=end;</span><br><span class="line">              <span class="keyword">do</span>&#123;</span><br><span class="line">                  <span class="keyword">while</span>((a[i]&lt;baseNum)&amp;&amp;i&lt;end)&#123;</span><br><span class="line">                      i++;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">while</span>((a[j]&gt;baseNum)&amp;&amp;j&gt;start)&#123;</span><br><span class="line">                      j--;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span>(i&lt;=j)&#123;</span><br><span class="line">                      midNum=a[i];</span><br><span class="line">                      a[i]=a[j];</span><br><span class="line">                      a[j]=midNum;</span><br><span class="line">                      i++;</span><br><span class="line">                      j--;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;<span class="keyword">while</span>(i&lt;=j);</span><br><span class="line">               <span class="keyword">if</span>(start&lt;j)&#123;</span><br><span class="line">                   quickSort(a,start,j);</span><br><span class="line">               &#125;       </span><br><span class="line">               <span class="keyword">if</span>(end&gt;i)&#123;</span><br><span class="line">                   quickSort(a,i,end);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ul><li>7、归并排序<br>速度仅次于快速排序，内存少的时候使用，可以进行并行计算的时候使用。<br>选择相邻两个数组成一个有序序列。<br>选择相邻的两个有序序列组成一个有序序列。<br>重复第二步，直到全部组成一个有序序列。</li></ul><p><img src="https://img-blog.csdn.net/20180801163954573?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">int</span> t = <span class="number">1</span>;<span class="comment">// 每组元素个数  </span></span><br><span class="line">          <span class="keyword">int</span> size = right - left + <span class="number">1</span>;  </span><br><span class="line">          <span class="keyword">while</span> (t &lt; size) &#123;  </span><br><span class="line">              <span class="keyword">int</span> s = t;<span class="comment">// 本次循环每组元素个数  </span></span><br><span class="line">              t = <span class="number">2</span> * s;  </span><br><span class="line">              <span class="keyword">int</span> i = left;  </span><br><span class="line">              <span class="keyword">while</span> (i + (t - <span class="number">1</span>) &lt; size) &#123;  </span><br><span class="line">                  merge(a, i, i + (s - <span class="number">1</span>), i + (t - <span class="number">1</span>));  </span><br><span class="line">                  i += t;  </span><br><span class="line">              &#125;  </span><br><span class="line">              <span class="keyword">if</span> (i + (s - <span class="number">1</span>) &lt; right)  </span><br><span class="line">                  merge(a, i, i + (s - <span class="number">1</span>), right);  </span><br><span class="line">          &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">      </span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];  </span><br><span class="line">          <span class="keyword">int</span> s = p;  </span><br><span class="line">          <span class="keyword">int</span> t = q + <span class="number">1</span>;  </span><br><span class="line">          <span class="keyword">int</span> k = p;  </span><br><span class="line">          <span class="keyword">while</span> (s &lt;= q &amp;&amp; t &lt;= r) &#123;  </span><br><span class="line">              <span class="keyword">if</span> (data[s] &lt;= data[t]) &#123;  </span><br><span class="line">                  B[k] = data[s];  </span><br><span class="line">                  s++;  </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                  B[k] = data[t];  </span><br><span class="line">                  t++;  </span><br><span class="line">              &#125;  </span><br><span class="line">              k++;  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">if</span> (s == q + <span class="number">1</span>)  </span><br><span class="line">              B[k++] = data[t++];  </span><br><span class="line">          <span class="keyword">else</span>  </span><br><span class="line">              B[k++] = data[s++];  </span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= r; i++)  </span><br><span class="line">              data[i] = B[i];  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><ul><li><p>8、基数排序<br>用于大量数，很长的数进行排序时。<br>将所有的数的个位数取出，按照个位数进行排序，构成一个序列。<br>将新构成的所有的数的十位数取出，按照十位数进行排序，构成一个序列。</p><p>代码实现：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">baseSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//首先确定排序的趟数;    </span></span><br><span class="line">              <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (a[i] &gt; max) &#123;</span><br><span class="line">                      max = a[i];</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">              <span class="comment">//判断位数;    </span></span><br><span class="line">              <span class="keyword">while</span> (max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  max /= <span class="number">10</span>;</span><br><span class="line">                  time++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//建立10个队列;    </span></span><br><span class="line">              List&lt;ArrayList&lt;Integer&gt;&gt; queue = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                  ArrayList&lt;Integer&gt; queue1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                  queue.add(queue1);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//进行time次分配和收集;    </span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</span><br><span class="line">                  <span class="comment">//分配数组元素;    </span></span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                      <span class="comment">//得到数字的第time+1位数;  </span></span><br><span class="line">                      <span class="keyword">int</span> x = a[j] % (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, i + <span class="number">1</span>) / (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, i);</span><br><span class="line">                      ArrayList&lt;Integer&gt; queue2 = queue.get(x);</span><br><span class="line">                      queue2.add(a[j]);</span><br><span class="line">                      queue.set(x, queue2);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//元素计数器;    </span></span><br><span class="line">                  <span class="comment">//收集队列元素;    </span></span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">                      <span class="keyword">while</span> (queue.get(k).size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                          ArrayList&lt;Integer&gt; queue3 = queue.get(k);</span><br><span class="line">                          a[count] = queue3.get(<span class="number">0</span>);</span><br><span class="line">                          queue3.remove(<span class="number">0</span>);</span><br><span class="line">                          count++;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>新建测试类进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="comment">//a[i]=(int)(new Random().nextInt(100));</span></span><br><span class="line">            a[i]=(<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"排序前的数组为："</span>+Arrays.toString(a));</span><br><span class="line">        Sort s=<span class="keyword">new</span> Sort();</span><br><span class="line">        <span class="comment">//排序方法测试</span></span><br><span class="line">        <span class="comment">//s.insertSort(a);</span></span><br><span class="line">        <span class="comment">//s.sheelSort(a);</span></span><br><span class="line">        <span class="comment">//s.selectSort(a);</span></span><br><span class="line">        <span class="comment">//s.heapSort(a);</span></span><br><span class="line">        <span class="comment">//s.bubbleSort(a);</span></span><br><span class="line">        <span class="comment">//s.quickSort(a, 1, 9);</span></span><br><span class="line">        <span class="comment">//s.mergeSort(a, 3, 7);</span></span><br><span class="line">        s.baseSort(a);</span><br><span class="line">        System.out.println(<span class="string">"排序后的数组为："</span>+Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分结果如下:</p><p><img src="https://img-blog.csdn.net/20180801164250720?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>如果要进行比较可已加入时间，输出排序时间，从而比较各个排序算法的优缺点，这里不再做介绍。</p><ul><li>8、总结：<br>一、稳定性:</li></ul><p>　 稳定：冒泡排序、插入排序、归并排序和基数排序</p><p>　　不稳定：选择排序、快速排序、希尔排序、堆排序</p><p>二、平均时间复杂度</p><p>　　O(n^2):直接插入排序，简单选择排序，冒泡排序。</p><p>　　在数据规模较小时（9W内），直接插入排序，简单选择排序差不多。当数据较大时，冒泡排序算法的时间代价最高。性能为O(n^2)的算法基本上是相邻元素进行比较，基本上都是稳定的。</p><p>　　O(nlogn):快速排序，归并排序，希尔排序，堆排序。</p><p>　　其中，快排是最好的， 其次是归并和希尔，堆排序在数据量很大时效果明显。</p><p>三、排序算法的选择</p><p>　　1.数据规模较小</p><p> 　　（1）待排序列基本序的情况下，可以选择直接插入排序；</p><p> 　　（2）对稳定性不作要求宜用简单选择排序，对稳定性有要求宜用插入或冒泡</p><p>　　2.数据规模不是很大</p><p>　　（1）完全可以用内存空间，序列杂乱无序，对稳定性没有要求，快速排序，此时要付出log（N）的额外空间。</p><p>　　（2）序列本身可能有序，对稳定性有要求，空间允许下，宜用归并排序</p><p>　　3.数据规模很大</p><p> 　　（1）对稳定性有求，则可考虑归并排序。</p><pre><code>　　（2）对稳定性没要求，宜用堆排序
</code></pre><p>　　4.序列初始基本有序（正序），宜用直接插入，冒泡</p><p> 各算法复杂度如下：</p><p><img src="https://img-blog.csdn.net/20180801164323823?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjk2NTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/2018/08/01/java/java/Java常用的八种排序算法与代码实现/">Java常用的八种排序算法与代码实现</a></p><p><span>文章作者:</span><a href="/" title="访问 QinHe 的个人博客">QinHe</a></p><p><span>发布时间:</span>2018年08月01日 - 17:08</p><p><span>最后更新:</span>2018年08月01日 - 17:08</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"> <img id="wechat_subscriber_qcode" src="/images/wechat-qcode.jpg" alt="QinHe wechat" style="width:200px;max-width:100%"><div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div></div></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/排序/" rel="tag"><i class="fa fa-tag"></i> 排序</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/08/01/java/springmvcAndSpringboot/AOP/" rel="next" title="AOP "><i class="fa fa-chevron-left"></i> AOP </a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2018/08/03/java/springmvcAndSpringboot/Shiro-Spring /" rel="prev" title="Shiro-Spring">Shiro-Spring<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="addthis_inline_share_toolbox"><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b3f66ffa7f921c2" async="async"></script></div></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNzkxMC8xNDQ0MA=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/portrait.jpg" alt="QinHe"><p class="site-author-name" itemprop="name">QinHe</p><p class="site-description motion-element" itemprop="description">我的征途是星辰大海</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">39</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/qinheJ" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:qinheJ@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://plus.google.com/qinheJ" target="_blank" title="Google"><i class="fa fa-fw fa-google"></i> Google</a></span><span class="links-of-author-item"><a href="https://twitter.com/yourname" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i> Twitter</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://macshuo.com/" title="MacTalk" target="_blank">MacTalk</a></li><li class="links-of-blogroll-item"> <a href="http://example.com/" title="Title" target="_blank">Title</a></li></ul></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">QinHe</span><div class="powered-by"><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_pv">本站访客数:<span id="busuanzi_value_site_pv"></span></span></div></div><div class="theme-info"><div class="powered-by"></div> <span class="post-count">博客全站共46.1k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/lib/three/three.min.js"></script><script type="text/javascript" src="/lib/three/three-waves.min.js"></script><script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css"><script src="/lib/algolia-instant-search/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=5.1.4"></script><canvas class="fireworks" style="position:fixed;left:0;top:0;z-index:1;pointer-events:none"></canvas><script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script type="text/javascript" src="/js/src/fireworks.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",display:{position:"right",width:100,height:150},mobile:{show:!1}})</script></body></html><script type="text/javascript" src="/js/src/love.js"></script>