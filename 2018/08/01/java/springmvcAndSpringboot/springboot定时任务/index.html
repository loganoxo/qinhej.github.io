<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script></script><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"ce3881c3"}),daovoice("update")</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="配置文件,"><link rel="alternate" href="/atom.xml" title="秦贺的博客" type="application/atom+xml"><meta name="description" content="一、白拿拿项目中需要每天凌晨统计一次昨天一天的邀请排行榜,与定时任务有关代码示例如下："><meta name="keywords" content="配置文件"><meta property="og:type" content="article"><meta property="og:title" content="springboot定时任务 "><meta property="og:url" content="http://yoursite.com/2018/08/01/java/springmvcAndSpringboot/springboot定时任务/index.html"><meta property="og:site_name" content="秦贺的博客"><meta property="og:description" content="一、白拿拿项目中需要每天凌晨统计一次昨天一天的邀请排行榜,与定时任务有关代码示例如下："><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2018-08-01T07:04:07.172Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="springboot定时任务 "><meta name="twitter:description" content="一、白拿拿项目中需要每天凌晨统计一次昨天一天的邀请排行榜,与定时任务有关代码示例如下："><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"QinHe"},algolia:{applicationID:"FNMQKMRSYO",apiKey:"1c7c5f8f7f7c31886eede32da3f67ed3",indexName:"hexo",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2018/08/01/java/springmvcAndSpringboot/springboot定时任务/"><title>springboot定时任务  | 秦贺的博客</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?df2f085ca1e73bf7063afbe80560f855";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/qinheJ" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff;color:#151513;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg><span style="color:#000;font-weight:700;position:absolute;top:0;border:0;right:0"><br><br>&emsp;Fork me on GitHub&emsp;</span></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">秦贺的博客</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/01/java/springmvcAndSpringboot/springboot定时任务/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="QinHe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/portrait.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="秦贺的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">springboot定时任务 </h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-01T15:04:07+08:00">2018-08-01</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/springmvc和springboot/" itemprop="url" rel="index"><span itemprop="name">springmvc和springboot</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">2,677</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">12</span></div></div></header><div class="post-body" itemprop="articleBody"><ul><li>一、白拿拿项目中需要每天凌晨统计一次昨天一天的邀请排行榜,与定时任务有关代码示例如下：<a id="more"></a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleHandler</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IChannelSourceConfigService channelSourceConfigService; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduleHandler</span><span class="params">(IChannelSourceConfigService channelSourceConfigService)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.channelSourceConfigService = channelSourceConfigService; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0 7 0 * * ?"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShowkerCountCache</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        channelSourceConfigService.refreshAll(); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二、当有多个定时器的时候 需要异步使用 增加定时器线程池配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@EnableScheduling</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleConfig</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123; </span><br><span class="line">        taskRegistrar.setScheduler(taskExecutor()); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>(destroyMethod = <span class="string">"shutdown"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> Executors.newScheduledThreadPool(<span class="number">100</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>三、详细内容</p><p> Spring 定时任务实例<br> Spring 中使用定时任务很简单，只需要@EnableScheudling 注解启用即可，并不要求是一个 Spring Mvc 的项目。<br> 对于一个 Spring Boot 项目，使用定时任务的简单方式如下：<br> pom.xml 中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"> 	 <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><pre><code>Application.java 
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span> </span><br><span class="line"><span class="meta">@SpringBootApplication</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123; </span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">	 	SpringApplication.run(Application.class, args); </span><br><span class="line">	 &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableScheduling 是必须的。默认时定时任务的线程是由 Executors.defaultThreadFactory() 产生的，线程名称是 “pool-NUMBER-thread-…”, 关键是线程的 daemon 属性为 false, 阻止了主线程的退出，使得任务能一遍遍执行。</p><p>SchedulRunner.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleRunner</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Scheduled</span>(fixedDelay = <span class="number">5000</span>) </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">job1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		System.out.println(Thread.currentThread() + <span class="string">", job1@"</span> + LocalTime.now()); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺带提一下注解@Scheduled的各个属性</p><ol><li>cron: 以 UN<em>X 的 cron 的方式定义 job, 如 “0</em><em></em> * NON-FRI”</li><li>fixedRate: 每次任务启动时的间隔时间，fixedRateString，意义是一样，只是可以通过外部来定义，如 fixedRateString = “${job1.fixed.rate}”</li><li>fixedDelay: 上次任务结束后间隔多少时间再启动下一次任务，这样避免前一个任务尚未结束又启动下一个任务，fixedDelayString 类似 fixedRateString</li><li>intialDelay: 程序启动后至任务首次执行时的间隔时间，针对 fixedRate(fixedRateString), fixedDelay(fixedDelayString)</li><li>zone: 给 cron 表达式用的时区</li><li>注意, 以上的时间都是毫秒</li></ol><p>&emsp;启动这个 Spring Boot 项目，可以看到 job1 每隔五分钟执行一次，并且全部由一个线程来执行<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:57:46.822<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:57:51.831<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:57:56.836<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:58:01.841<br>&emsp;居然总是同一个线程<br>&emsp;如果我们把上面的 fixedDelay 改成 fixedRate, 并且用 Thread.sleep(20000) 来模拟单次任务耗时 20 秒，试图让上次任务还在进行当中执行下一次任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleRunner</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">5000</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">job1</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(Thread.currentThread() + <span class="string">", job1@"</span> + LocalTime.now()); </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> Thread.sleep(<span class="number">20000</span>); </span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line"> 	 &#125; </span><br><span class="line"> 	 &#125; </span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure><p>&emsp;执行后，发现事与愿为<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:58:57.564<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:59:17.572<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:59:37.575<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:59:57.580<br>&emsp;&emsp;并非每五秒启动下一个任务，而是每隔20 秒，原来是只有一个线程来执行所有任务，后面的任务必须等前一个任务释放出了线程才能得到执行。我们可以理解为 Spring 在任务调度时，fixedRate, fixedDelay 或 cron 只是决定提交任务到线程池的时刻，至于真正执行任务的时间就看有没有空闲的线程，因此最终决定于线程池的配置。<br>&emsp;同样，如果我们在ScheduleRunner 中声明两个任务(后续的执行输出结果都以这两个任务为例)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleRunner</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">5000</span>) </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">job1</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(Thread.currentThread() + <span class="string">", job1@"</span> + LocalTime.now()); </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> Thread.sleep(<span class="number">20000</span>); </span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line"> 	 &#125; </span><br><span class="line"> 	 &#125; </span><br><span class="line"> 	 </span><br><span class="line"> 	 <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">5000</span>) </span><br><span class="line"> 	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">job2</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 	 System.out.println(Thread.currentThread() + <span class="string">", job2@"</span> + LocalTime.now()); </span><br><span class="line"> 	 &#125; </span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure><p>执行的效果是下面那样的<br>Thread[pool-1-thread-1,5,main], job2@22:05:12.236<br>Thread[pool-1-thread-1,5,main], job1@22:05:12.241<br>Thread[pool-1-thread-1,5,main], job2@22:05:32.244<br>Thread[pool-1-thread-1,5,main], job1@22:05:37.246<br>Thread[pool-1-thread-1,5,main], job2@22:05:57.250<br>Thread[pool-1-thread-1,5,main], job1@22:06:02.253<br>也是因为始终只有一个线程的缘故，任务调度无法按照预定的要求，job1 和 job2 不能同时进行，更别说 job1 或是 job2 的前后两次任务同时进行。job2 每次要等待 job1 执行完释放出线程来执行，所以不管 fixedDelay 或 fixedRate 配置多小的时间间隔，中间都至少要等 20 秒。<br>既然我们知晓了是单一线程的原因，那么再追根究底看看，以及解决办法是什么？<br>如何创建任务线程的？<br>查看源代码是最有效的，采用顺藤摸瓜的办法，从 @EnableScheduling 起，在 EnableScheduling 中找到 @see ScheduledAnnotationBeanPostProcessor, 来到ScheduledAnnotationBeanPostProcessor.setScheduler(Object scheduler)方法的 JavaDoc<br>说的是定时任务需要一个线程池(TaskScheduler 或 ScheduledExecutorService) 来执行，Spring 会通过以下顺序去获得 TaskScheduler 或是 ScheduledExecutorService 包装为 TaskScheduler 实例<br> 1、类型为 TaskScheduler 的唯一 Bean<br> 2、如果第 1 步未找到，或找到多个就尝试查找名称为 “taskScheduler”, 类型为 TaskScheduler 的 Bean<br> 3、查找类型为 ScheduledExecutorService 的 Bean, 并包装为 TaskScheduler 实例<br> 4、如果第 3 步未到，或找到多个就尝试查找 名称为”taskScheduler”, 类型为 ScheduledExecutorService 的 Bean, 并包装为 TaskScheduler 实例</p><p>也就是可以定一唯的类型为 TaskScheduler 或 ScheduledExecutorService 的 Bean, 或者是名称为 “taskScheduler” 的 TaskScheduler 或 ScheduledExecutorService 实例。</p><p>查找 TaskScheduler 的方法是ScheduledAnnotationBeanPostProcessor.finishRegistration(), 点接该链接查看源代码。<br>找到了 TaskScheduler 或 ScheduledExecutorService 后设置 Scheduler 的代码如下，在ScheduledTaskRegistrar类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScheduler</span><span class="params">(Object scheduler)</span> </span>&#123; </span><br><span class="line">Assert.notNull(scheduler, <span class="string">"Scheduler object must not be null"</span>); </span><br><span class="line"><span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TaskScheduler) &#123; </span><br><span class="line"><span class="keyword">this</span>.taskScheduler = (TaskScheduler) scheduler; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> ScheduledExecutorService) &#123; </span><br><span class="line"><span class="keyword">this</span>.taskScheduler = <span class="keyword">new</span> ConcurrentTaskScheduler(((ScheduledExecutorService) scheduler)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line"> 	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported scheduler type: "</span> + scheduler.getClass()); </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure><p>对 ScheduledExecutorService 的包装是通过 ConsurrentTaskScheduler 类。<br>而在 ScheduledTaskRegistrar 中注册任务是由 scheduleTasks() 实现的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 	 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">scheduleTasks</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">if</span> (<span class="keyword">this</span>.taskScheduler == <span class="keyword">null</span>) &#123; </span><br><span class="line"> 	<span class="keyword">this</span>.localExecutor = Executors.newSingleThreadScheduledExecutor(); </span><br><span class="line"> 	<span class="keyword">this</span>.taskScheduler = <span class="keyword">new</span> ConcurrentTaskScheduler(<span class="keyword">this</span>.localExecutor); </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	...... </span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure><p>这才看到为什么默认情况下 Spring 用单线程来执行所有的任务, 因为 Spring 未定义 TaskScheduler 和 ScheduledExecutorService 这两个实例。此名，上面的<br>Executors.newSingleThreadScheduledExecutor()<br>最终会调用 Executors.defaultThreadFactory() 来创建 daemon 为 false 的线程。</p><ul><li>四、提供自定义的任务线程池</li></ul><p>一般来说，只用一个线程来执行所有的任务是满足不了我们的需求的，除非项目中只有一个任务时的以下两种情况<br>• 用 fixedDelay 来配置的<br>• fixedRate 或 cron, 并且在时间间隔内每次任务必须能执行完成<br>知道了来龙去脉，就可以参考上面 1, 2, 3, 4 的顺序来定义一个自己的 TaskScheduler 来 ScheduledExecutorService 实例<br>• 类型为 TaskScheduler 或 ScheduledExecutorService 的实例<br>• 名称为 “taskScheduler” 的 TaskScheduler 或 ScheduledExecutorService 实例<br>TaskScheduler 接口有三个实现，分别是 ThreadPoolTaskScheduler,<br>ConcurrentTaskScheduler, 和 DefaultMangedTaskScheduler(继承自 ConsurrentTaskScheduler)<br>ScheduledExecutorService 接口有两个实现类，分别是 ScheduledThreadPoolExecutor<br>DelegatedScheduledExecutorService<br>下面是几个例子，可在前面的 Application 类中配置一个 @Bean, 代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 	 <span class="meta">@Bean</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> TaskScheduler <span class="title">taskScheduler</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 	ThreadPoolTaskScheduler taskScheduler = <span class="keyword">new</span> ThreadPoolTaskScheduler(); </span><br><span class="line"> 	taskScheduler.setPoolSize(<span class="number">5</span>); </span><br><span class="line"> 	<span class="keyword">return</span> taskScheduler; </span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure><p>再次运行<br><br>Thread[taskScheduler-1,5,main], job2@23:21:09.307<br><br>Thread[taskScheduler-2,5,main], job1@23:21:09.307<br><br>Thread[taskScheduler-1,5,main], job2@23:21:14.315<br><br>Thread[taskScheduler-3,5,main], job2@23:21:19.318<br><br>Thread[taskScheduler-1,5,main], job2@23:21:24.322<br><br>Thread[taskScheduler-1,5,main], job2@23:21:29.326<br><br>Thread[taskScheduler-2,5,main], job1@23:21:34.320<br><br>Thread[taskScheduler-4,5,main], job2@23:21:34.327<br><br><br><br>现在分别由不同的的线程来执行各自的任务，互不干涉，每次任务由谁来执行只取决于池中的空闲线程。现在终于是 job1 每 25(20+5) 秒， job2 每 5 秒执行一次。应用中应根据任务间隔与每个任务执行时长来配置线程池的大小。此时线程池的名称是 TaskScheduler Bean 的名称，所以我们想改变线程池名称的话可以命一个新的 Bean 名称，改方法名或是指定 @Bean 的 name 属性，如<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="meta">@Bean</span>(name = <span class="string">"TaskPool"</span>) </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> TaskScheduler <span class="title">taskScheduler</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 	..... </span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure><p><br>那么执行后打印的线程名称是<br><br>Thread[TaskPool-2,5,main], job1@23:26:09.330<br><br>Thread[TaskPool-1,5,main], job2@23:26:09.330<br><br>线程 daemon 应该是 false, 除非主线程自己不退<br><br>注意，如果是自己定义的线程池不能把线程的 daemon 设置为 true, 否则主线程很快退出进而整个进程结束，那就不是定时任务了。例如我们声明如下的 taskScheduler<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> TaskScheduler <span class="title">taskScheduler</span><span class="params">()</span> </span>&#123; </span><br><span class="line">AtomicInteger number = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>); </span><br><span class="line">ConcurrentTaskScheduler taskScheduler = <span class="keyword">new</span> ConcurrentTaskScheduler( </span><br><span class="line">Executors.newScheduledThreadPool(<span class="number">3</span>, r -&gt; &#123; </span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(r); </span><br><span class="line">thread.setName(<span class="string">"TaskPool-thread-"</span> + number.getAndIncrement()); </span><br><span class="line">thread.setDaemon(<span class="keyword">true</span>); <span class="comment">//daemon 为 true 导致主线程很快退出，从而进程退出 </span></span><br><span class="line"><span class="keyword">return</span> thread; </span><br><span class="line"> 	&#125;)); </span><br><span class="line"> 	<span class="keyword">return</span> taskScheduler; </span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure><p><br>执行程序后的效果可能是这样的<br><br>这还比较幸运，任务被执行了一次，进程退出了，也有可能一次任务都无法执行，如果是 fixedDelay 稍长的任务更是不可能得到一次执行的机会进程就退出了。如果你的主线程自己控制了永不退出也是可行的。<br><br>这种情况下，我们一般是不会这么干 – 把线程的 daemon 设置为 true，这也就是为什么 ConcurrentTaskScheduler 接收的是一个 ScheduledExecutorService 参数。<br><br>名称 “taskScheduler” 或类型 “ScheduledExecutorService” 来查找相应的 Bean, 如果都没有找到，就会使用默认的单线程的 scheduler 来 执行任务，这就是我们之前看到的效果。</p><p>@Scheduled 与 @Async<br>还是有必要提到一种情况，@Scheduled 和 @Async 是可以共存的。可以试着这么做<br>• 给 Application 类加上 @EnableAsync<br>• 给 ScheduleRunner 的 job1() 和 job2() 方法加上注解 @Async<br>执行后<br><br>Thread[SimpleAsyncTaskExecutor-1,5,main], job1@00:13:36.763<br><br>Thread[SimpleAsyncTaskExecutor-2,5,main], job2@00:13:36.763<br><br>Thread[SimpleAsyncTaskExecutor-3,5,main], job1@00:13:41.738<br><br>Thread[SimpleAsyncTaskExecutor-4,5,main], job2@00:13:41.738<br><br>Thread[SimpleAsyncTaskExecutor-5,5,main], job1@00:13:46.742<br><br>Thread[SimpleAsyncTaskExecutor-6,5,main], job2@00:13:46.742<br><br>SimpleAsyncTaskExecutor 并不使用线程池来执行任务，而是每次创建新的线程来执行任务，由于 job1() 和 job2() 两方法是异步的，所以 fixedDelay 的效果与 fixedRate 是一样的，因为方法一调用即认为是结束，马上就安排下一次执行的时间。如果想用 fixedDelay 让前后两次任务是有关联的，方法不能为 @Async.<br><br><br><br>给自己备注一下：<br><br>用 @Scheduled 标注的方法最后是包装到ScheduledMethodRunnable 中被执行的，它是一个 Runnable 接口的实现<br><br>Runnable runnable = new ScheduledMethodRunnable(bean, invocableMethod);</p></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/2018/08/01/java/springmvcAndSpringboot/springboot定时任务/">springboot定时任务 </a></p><p><span>文章作者:</span><a href="/" title="访问 QinHe 的个人博客">QinHe</a></p><p><span>发布时间:</span>2018年08月01日 - 15:08</p><p><span>最后更新:</span>2018年08月01日 - 15:08</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"> <img id="wechat_subscriber_qcode" src="/images/wechat-qcode.jpg" alt="QinHe wechat" style="width:200px;max-width:100%"><div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div></div></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/配置文件/" rel="tag"><i class="fa fa-tag"></i> 配置文件</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/08/01/java/springmvcAndSpringboot/springboot与swagger与zuul整合/" rel="next" title="springboot与swagger与zuul整合 "><i class="fa fa-chevron-left"></i> springboot与swagger与zuul整合 </a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2018/08/01/java/springmvcAndSpringboot/springboot异步/" rel="prev" title="springboot异步 ">springboot异步 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="addthis_inline_share_toolbox"><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b3f66ffa7f921c2" async="async"></script></div></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNzkxMC8xNDQ0MA=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/portrait.jpg" alt="QinHe"><p class="site-author-name" itemprop="name">QinHe</p><p class="site-description motion-element" itemprop="description">我的征途是星辰大海</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">39</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/qinheJ" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:qinheJ@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://plus.google.com/qinheJ" target="_blank" title="Google"><i class="fa fa-fw fa-google"></i> Google</a></span><span class="links-of-author-item"><a href="https://twitter.com/yourname" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i> Twitter</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://macshuo.com/" title="MacTalk" target="_blank">MacTalk</a></li><li class="links-of-blogroll-item"> <a href="http://example.com/" title="Title" target="_blank">Title</a></li></ul></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">QinHe</span><div class="powered-by"><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_pv">本站访客数:<span id="busuanzi_value_site_pv"></span></span></div></div><div class="theme-info"><div class="powered-by"></div> <span class="post-count">博客全站共46.1k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/lib/three/three.min.js"></script><script type="text/javascript" src="/lib/three/three-waves.min.js"></script><script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css"><script src="/lib/algolia-instant-search/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=5.1.4"></script><canvas class="fireworks" style="position:fixed;left:0;top:0;z-index:1;pointer-events:none"></canvas><script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script type="text/javascript" src="/js/src/fireworks.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",display:{position:"right",width:100,height:150},mobile:{show:!1}})</script></body></html><script type="text/javascript" src="/js/src/love.js"></script>