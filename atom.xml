<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秦贺的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-18T12:06:33.370Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>QinHe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springboot定时任务 </title>
    <link href="http://yoursite.com/2018/07/18/java/springmvcAndSpringboot/springboot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/07/18/java/springmvcAndSpringboot/springboot定时任务/</id>
    <published>2018-07-18T12:06:33.368Z</published>
    <updated>2018-07-18T12:06:33.370Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一、白拿拿项目中需要每天凌晨统计一次昨天一天的邀请排行榜,与定时任务有关代码示例如下：  <a id="more"></a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleHandler</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IChannelSourceConfigService channelSourceConfigService; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduleHandler</span><span class="params">(IChannelSourceConfigService channelSourceConfigService)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.channelSourceConfigService = channelSourceConfigService; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0 7 0 * * ?"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShowkerCountCache</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        channelSourceConfigService.refreshAll(); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二、当有多个定时器的时候  需要异步使用 增加定时器线程池配置 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@EnableScheduling</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleConfig</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123; </span><br><span class="line">        taskRegistrar.setScheduler(taskExecutor()); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>(destroyMethod = <span class="string">"shutdown"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> Executors.newScheduledThreadPool(<span class="number">100</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>三、详细内容  </p><p>  Spring 定时任务实例<br>  Spring 中使用定时任务很简单，只需要@EnableScheudling 注解启用即可，并不要求是一个 Spring Mvc 的项目。<br>  对于一个 Spring Boot 项目，使用定时任务的简单方式如下：<br>  pom.xml 中 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><pre><code>Application.java </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span> </span><br><span class="line"><span class="meta">@SpringBootApplication</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> SpringApplication.run(Application.class, args); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableScheduling 是必须的。默认时定时任务的线程是由 Executors.defaultThreadFactory() 产生的，线程名称是 “pool-NUMBER-thread-…”, 关键是线程的 daemon 属性为 false, 阻止了主线程的退出，使得任务能一遍遍执行。   </p><p>SchedulRunner.java </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleRunner</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Scheduled</span>(fixedDelay = <span class="number">5000</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">job1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(Thread.currentThread() + <span class="string">", job1@"</span> + LocalTime.now()); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺带提一下注解@Scheduled的各个属性 </p><ol><li>cron: 以 UN<em>X 的 cron 的方式定义 job, 如 “0 </em> <em> </em> * NON-FRI” </li><li>fixedRate: 每次任务启动时的间隔时间，fixedRateString，意义是一样，只是可以通过外部来定义，如 fixedRateString = “${job1.fixed.rate}” </li><li>fixedDelay: 上次任务结束后间隔多少时间再启动下一次任务，这样避免前一个任务尚未结束又启动下一个任务，fixedDelayString 类似 fixedRateString </li><li>intialDelay: 程序启动后至任务首次执行时的间隔时间，针对 fixedRate(fixedRateString), fixedDelay(fixedDelayString) </li><li>zone: 给 cron 表达式用的时区   </li><li>注意, 以上的时间都是毫秒   </li></ol><p>&emsp;启动这个 Spring Boot 项目，可以看到 job1 每隔五分钟执行一次，并且全部由一个线程来执行<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:57:46.822<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:57:51.831<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:57:56.836<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:58:01.841<br>&emsp;居然总是同一个线程<br>&emsp;如果我们把上面的 fixedDelay 改成 fixedRate, 并且用 Thread.sleep(20000) 来模拟单次任务耗时 20 秒，试图让上次任务还在进行当中执行下一次任务 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleRunner</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">5000</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">job1</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(Thread.currentThread() + <span class="string">", job1@"</span> + LocalTime.now()); </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> Thread.sleep(<span class="number">20000</span>); </span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">  &#125; </span><br><span class="line">  &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&emsp;执行后，发现事与愿为<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:58:57.564<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:59:17.572<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:59:37.575<br>&emsp;Thread[pool-1-thread-1,5,main], job1@21:59:57.580<br>&emsp;&emsp;并非每五秒启动下一个任务，而是每隔20 秒，原来是只有一个线程来执行所有任务，后面的任务必须等前一个任务释放出了线程才能得到执行。我们可以理解为 Spring 在任务调度时，fixedRate, fixedDelay 或 cron 只是决定提交任务到线程池的时刻，至于真正执行任务的时间就看有没有空闲的线程，因此最终决定于线程池的配置。<br>&emsp;同样，如果我们在ScheduleRunner 中声明两个任务(后续的执行输出结果都以这两个任务为例) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleRunner</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">5000</span>) </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">job1</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(Thread.currentThread() + <span class="string">", job1@"</span> + LocalTime.now()); </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> Thread.sleep(<span class="number">20000</span>); </span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">  &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">5000</span>) </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">job2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  System.out.println(Thread.currentThread() + <span class="string">", job2@"</span> + LocalTime.now()); </span><br><span class="line">  &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>执行的效果是下面那样的<br>Thread[pool-1-thread-1,5,main], job2@22:05:12.236<br>Thread[pool-1-thread-1,5,main], job1@22:05:12.241<br>Thread[pool-1-thread-1,5,main], job2@22:05:32.244<br>Thread[pool-1-thread-1,5,main], job1@22:05:37.246<br>Thread[pool-1-thread-1,5,main], job2@22:05:57.250<br>Thread[pool-1-thread-1,5,main], job1@22:06:02.253<br>也是因为始终只有一个线程的缘故，任务调度无法按照预定的要求，job1 和 job2 不能同时进行，更别说 job1 或是 job2 的前后两次任务同时进行。job2 每次要等待 job1 执行完释放出线程来执行，所以不管 fixedDelay 或 fixedRate 配置多小的时间间隔，中间都至少要等 20 秒。<br>既然我们知晓了是单一线程的原因，那么再追根究底看看，以及解决办法是什么？<br>如何创建任务线程的？<br>查看源代码是最有效的，采用顺藤摸瓜的办法，从 @EnableScheduling 起，在 EnableScheduling 中找到 @see ScheduledAnnotationBeanPostProcessor, 来到ScheduledAnnotationBeanPostProcessor.setScheduler(Object scheduler)方法的 JavaDoc<br>说的是定时任务需要一个线程池(TaskScheduler 或 ScheduledExecutorService) 来执行，Spring 会通过以下顺序去获得 TaskScheduler 或是 ScheduledExecutorService 包装为 TaskScheduler 实例<br> 1、类型为 TaskScheduler 的唯一 Bean<br> 2、如果第 1 步未找到，或找到多个就尝试查找名称为 “taskScheduler”, 类型为 TaskScheduler 的 Bean<br> 3、查找类型为 ScheduledExecutorService 的 Bean, 并包装为 TaskScheduler 实例<br> 4、如果第 3 步未到，或找到多个就尝试查找 名称为”taskScheduler”, 类型为 ScheduledExecutorService 的 Bean, 并包装为 TaskScheduler 实例   </p><p>也就是可以定一唯的类型为 TaskScheduler 或 ScheduledExecutorService 的 Bean, 或者是名称为 “taskScheduler” 的 TaskScheduler 或 ScheduledExecutorService 实例。   </p><p>查找 TaskScheduler 的方法是ScheduledAnnotationBeanPostProcessor.finishRegistration(), 点接该链接查看源代码。<br>找到了 TaskScheduler 或 ScheduledExecutorService 后设置 Scheduler 的代码如下，在ScheduledTaskRegistrar类中 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScheduler</span><span class="params">(Object scheduler)</span> </span>&#123; </span><br><span class="line">Assert.notNull(scheduler, <span class="string">"Scheduler object must not be null"</span>); </span><br><span class="line"><span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TaskScheduler) &#123; </span><br><span class="line"><span class="keyword">this</span>.taskScheduler = (TaskScheduler) scheduler; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> ScheduledExecutorService) &#123; </span><br><span class="line"><span class="keyword">this</span>.taskScheduler = <span class="keyword">new</span> ConcurrentTaskScheduler(((ScheduledExecutorService) scheduler)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported scheduler type: "</span> + scheduler.getClass()); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>对 ScheduledExecutorService 的包装是通过 ConsurrentTaskScheduler 类。<br>而在 ScheduledTaskRegistrar 中注册任务是由 scheduleTasks() 实现的， </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">scheduleTasks</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.taskScheduler == <span class="keyword">null</span>) &#123; </span><br><span class="line"> <span class="keyword">this</span>.localExecutor = Executors.newSingleThreadScheduledExecutor(); </span><br><span class="line"> <span class="keyword">this</span>.taskScheduler = <span class="keyword">new</span> ConcurrentTaskScheduler(<span class="keyword">this</span>.localExecutor); </span><br><span class="line"> &#125; </span><br><span class="line"> ...... </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这才看到为什么默认情况下 Spring 用单线程来执行所有的任务, 因为 Spring 未定义 TaskScheduler 和 ScheduledExecutorService 这两个实例。此名，上面的<br>Executors.newSingleThreadScheduledExecutor()<br>最终会调用 Executors.defaultThreadFactory() 来创建 daemon 为 false 的线程。 </p><ul><li>四、提供自定义的任务线程池   </li></ul><p>一般来说，只用一个线程来执行所有的任务是满足不了我们的需求的，除非项目中只有一个任务时的以下两种情况<br>• 用 fixedDelay 来配置的<br>• fixedRate 或 cron, 并且在时间间隔内每次任务必须能执行完成<br>知道了来龙去脉，就可以参考上面 1, 2, 3, 4 的顺序来定义一个自己的 TaskScheduler 来 ScheduledExecutorService 实例<br>• 类型为 TaskScheduler 或 ScheduledExecutorService 的实例<br>• 名称为 “taskScheduler” 的 TaskScheduler 或 ScheduledExecutorService 实例<br>TaskScheduler 接口有三个实现，分别是 ThreadPoolTaskScheduler,<br>ConcurrentTaskScheduler, 和 DefaultMangedTaskScheduler(继承自 ConsurrentTaskScheduler)<br>ScheduledExecutorService 接口有两个实现类，分别是 ScheduledThreadPoolExecutor<br>DelegatedScheduledExecutorService<br>下面是几个例子，可在前面的 Application 类中配置一个 @Bean, 代码如下 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Bean</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> TaskScheduler <span class="title">taskScheduler</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> ThreadPoolTaskScheduler taskScheduler = <span class="keyword">new</span> ThreadPoolTaskScheduler(); </span><br><span class="line"> taskScheduler.setPoolSize(<span class="number">5</span>); </span><br><span class="line"> <span class="keyword">return</span> taskScheduler; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再次运行<br><br>Thread[taskScheduler-1,5,main], job2@23:21:09.307<br><br>Thread[taskScheduler-2,5,main], job1@23:21:09.307<br><br>Thread[taskScheduler-1,5,main], job2@23:21:14.315<br><br>Thread[taskScheduler-3,5,main], job2@23:21:19.318<br><br>Thread[taskScheduler-1,5,main], job2@23:21:24.322<br><br>Thread[taskScheduler-1,5,main], job2@23:21:29.326<br><br>Thread[taskScheduler-2,5,main], job1@23:21:34.320<br><br>Thread[taskScheduler-4,5,main], job2@23:21:34.327<br><br><br><br>现在分别由不同的的线程来执行各自的任务，互不干涉，每次任务由谁来执行只取决于池中的空闲线程。现在终于是 job1 每 25(20+5) 秒， job2 每 5 秒执行一次。应用中应根据任务间隔与每个任务执行时长来配置线程池的大小。此时线程池的名称是 TaskScheduler Bean 的名称，所以我们想改变线程池名称的话可以命一个新的 Bean 名称，改方法名或是指定 @Bean 的 name 属性，如 <br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Bean</span>(name = <span class="string">"TaskPool"</span>) </span><br><span class="line"> <span class="function"><span class="keyword">public</span> TaskScheduler <span class="title">taskScheduler</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> ..... </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><br>那么执行后打印的线程名称是<br><br>Thread[TaskPool-2,5,main], job1@23:26:09.330<br><br>Thread[TaskPool-1,5,main], job2@23:26:09.330<br><br>线程 daemon 应该是 false, 除非主线程自己不退<br><br>注意，如果是自己定义的线程池不能把线程的 daemon 设置为 true, 否则主线程很快退出进而整个进程结束，那就不是定时任务了。例如我们声明如下的 taskScheduler <br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> TaskScheduler <span class="title">taskScheduler</span><span class="params">()</span> </span>&#123; </span><br><span class="line">AtomicInteger number = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>); </span><br><span class="line">ConcurrentTaskScheduler taskScheduler = <span class="keyword">new</span> ConcurrentTaskScheduler( </span><br><span class="line">Executors.newScheduledThreadPool(<span class="number">3</span>, r -&gt; &#123; </span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(r); </span><br><span class="line">thread.setName(<span class="string">"TaskPool-thread-"</span> + number.getAndIncrement()); </span><br><span class="line">thread.setDaemon(<span class="keyword">true</span>); <span class="comment">//daemon 为 true 导致主线程很快退出，从而进程退出 </span></span><br><span class="line"><span class="keyword">return</span> thread; </span><br><span class="line"> &#125;)); </span><br><span class="line"> <span class="keyword">return</span> taskScheduler; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><br>执行程序后的效果可能是这样的<br><br>这还比较幸运，任务被执行了一次，进程退出了，也有可能一次任务都无法执行，如果是 fixedDelay 稍长的任务更是不可能得到一次执行的机会进程就退出了。如果你的主线程自己控制了永不退出也是可行的。<br><br>这种情况下，我们一般是不会这么干 – 把线程的 daemon 设置为 true，这也就是为什么 ConcurrentTaskScheduler 接收的是一个 ScheduledExecutorService 参数。<br><br>名称 “taskScheduler” 或类型 “ScheduledExecutorService” 来查找相应的 Bean, 如果都没有找到，就会使用默认的单线程的 scheduler 来 执行任务，这就是我们之前看到的效果。   </p><p>@Scheduled 与 @Async<br>还是有必要提到一种情况，@Scheduled 和 @Async 是可以共存的。可以试着这么做<br>• 给 Application 类加上 @EnableAsync<br>• 给 ScheduleRunner 的 job1() 和 job2() 方法加上注解 @Async<br>执行后<br><br>Thread[SimpleAsyncTaskExecutor-1,5,main], job1@00:13:36.763<br><br>Thread[SimpleAsyncTaskExecutor-2,5,main], job2@00:13:36.763<br><br>Thread[SimpleAsyncTaskExecutor-3,5,main], job1@00:13:41.738<br><br>Thread[SimpleAsyncTaskExecutor-4,5,main], job2@00:13:41.738<br><br>Thread[SimpleAsyncTaskExecutor-5,5,main], job1@00:13:46.742<br><br>Thread[SimpleAsyncTaskExecutor-6,5,main], job2@00:13:46.742<br><br>SimpleAsyncTaskExecutor 并不使用线程池来执行任务，而是每次创建新的线程来执行任务，由于 job1() 和 job2() 两方法是异步的，所以 fixedDelay 的效果与 fixedRate 是一样的，因为方法一调用即认为是结束，马上就安排下一次执行的时间。如果想用 fixedDelay 让前后两次任务是有关联的，方法不能为 @Async.<br><br><br><br>给自己备注一下：<br><br>用 @Scheduled 标注的方法最后是包装到ScheduledMethodRunnable 中被执行的，它是一个 Runnable 接口的实现<br><br>Runnable runnable = new ScheduledMethodRunnable(bean, invocableMethod); </p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;一、白拿拿项目中需要每天凌晨统计一次昨天一天的邀请排行榜,与定时任务有关代码示例如下：
    
    </summary>
    
      <category term="springmvc和springboot" scheme="http://yoursite.com/categories/springmvc%E5%92%8Cspringboot/"/>
    
    
      <category term="配置文件" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2018/07/18/java/springmvcAndSpringboot/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/07/18/java/springmvcAndSpringboot/线程池/</id>
    <published>2018-07-18T11:36:01.077Z</published>
    <updated>2018-07-18T11:36:01.078Z</updated>
    
    <content type="html"><![CDATA[<ul><li>线程池:  </li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="class"><span class="keyword">class</span> <span class="title">CommonTest</span></span>&#123; </span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;   </span><br><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">ExecutorService executorService =Executors.newFixedThreadPool(<span class="number">100</span>); </span><br><span class="line">FutureTask&lt;String&gt; futureTask= <span class="keyword">new</span> FutureTask&lt;String&gt;(newCallable&lt;String&gt;()&#123; </span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function">Public String <span class="title">call</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123; </span><br><span class="line">thrownewException(<span class="string">"adasd"</span>); </span><br><span class="line">&#125;&#125;); </span><br><span class="line">executorService.execute(futureTask); </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>==<span class="number">1</span>)&#123; </span><br><span class="line">Boolean done= futureTask.isDone(); </span><br><span class="line"><span class="keyword">if</span>(done)&#123; </span><br><span class="line">System.out.println(futureTask.get()); </span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;<span class="keyword">else</span>&#123; </span><br><span class="line">System.out.println(<span class="string">"joijoi"</span>); </span><br><span class="line">&#125;&#125; </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exceptione)&#123; </span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;线程池:  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="springmvc和springboot" scheme="http://yoursite.com/categories/springmvc%E5%92%8Cspringboot/"/>
    
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>springboot配置文件 </title>
    <link href="http://yoursite.com/2018/07/18/java/springmvcAndSpringboot/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/07/18/java/springmvcAndSpringboot/springboot配置文件/</id>
    <published>2018-07-18T10:33:48.024Z</published>
    <updated>2018-07-18T10:33:48.026Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1、Profile-多环境配置  </li></ul><p>&emsp;&emsp;当应用程序需要部署到不同运行环境时，一些配置细节通常会有所不同，最简单的比如日志，生产日志会将日志级别设置为WARN或更高级别，并将日志写入日志文件，而开发的时候需要日志级别为DEBUG，日志输出到控制台即可。<br>如果按照以前的做法，就是每次发布的时候替换掉配置文件，这样太麻烦了，Spring Boot的Profile就给我们提供了解决方案，命令带上参数就搞定。 </p><p>这里我们来模拟一下，只是简单的修改端口来测试。<br>在Spring Boot中多环境配置文件名需要满足<code>application-{profile}.properties</code>的格式，其中<code>{profile}</code>对应你的环境标识，比如： </p><ul><li>application-dev.properties：开发环境 </li><li>application-prod.properties：生产环境 </li></ul><p>想要使用对应的环境，只需要在application.properties中使用spring.profiles.active属性来设置，值对应上面提到的{profile}，这里就是指dev、prod这2个。 </p><p>当然你也可以用命令行启动的时候带上参数： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">java -jar xxx.jar --spring.profiles.active=dev</span><br></pre></td></tr></table></figure><p>优先级：测试环境：（加参数dev）<br>Application.properties&gt;Application.yml&gt;bootstrap-dev.yml&gt;bootstrap.yml </p><p>不加参数的时候  dev配置文件就不会被扫描到   </p><ul><li><p>2、配置文件的引入</p><ul><li>@ComponentScan 表示扫描那个包下的bean到spring容器中，通常放在application.class上，在@SpringBootApplication里面集成了这个配置，通常这个类放在最外层，这个注解就保证了扫描里面所有包路径下的bean  </li><li>导入外部配置文件：<br>@PropertySource(value={“classpath:jdbc.properties”,””},ignoreResourceNotFound=true) </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;1、Profile-多环境配置  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;当应用程序需要部署到不同运行环境时，一些配置细节通常会有所不同，最简单的比如日志，生产日志会将日志级别设置为WARN或更高级别，并将日志写入日志文件，而开发的时候需要日志级别
      
    
    </summary>
    
      <category term="springmvc和springboot" scheme="http://yoursite.com/categories/springmvc%E5%92%8Cspringboot/"/>
    
    
      <category term="配置文件" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>springboot异步 </title>
    <link href="http://yoursite.com/2018/07/18/java/springmvcAndSpringboot/springboot%E5%BC%82%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/07/18/java/springmvcAndSpringboot/springboot异步/</id>
    <published>2018-07-18T10:16:42.219Z</published>
    <updated>2018-07-18T10:15:55.639Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在做白拿拿项目的时候，有一些不需要即时完成的，也不需要即时获取返回值的工作，可以放到异步方法中执行，原理是springboot会自动开启另一个线程去做这件事</p><p>实现方法：  </p><ul><li><p>1.启动类上要有一个注解开启异步  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2.在那个方法上加上注解 ，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Async</span> </span><br><span class="line"> <span class="function">publicFuture&lt;String&gt; <span class="title">doTaskOne</span><span class="params">()</span> throwsException </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">"开始做任务一"</span>); </span><br><span class="line"> longstart = System.currentTimeMillis(); </span><br><span class="line"> Thread.sleep(random.nextInt(<span class="number">10000</span>)); </span><br><span class="line"> longend = System.currentTimeMillis(); </span><br><span class="line"> System.out.println(<span class="string">"完成任务一，耗时："</span>+ (end - start) +<span class="string">"毫秒"</span>); </span><br><span class="line"> returnnewAsyncResult&lt;&gt;(<span class="string">"任务一完成"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在做白拿拿项目的时候，有一些不需要即时完成的，也不需要即时获取返回值的工作，可以放到异步方法中执行，原理是springboot会自动开启另一个线程去做这件事&lt;/p&gt;
&lt;p&gt;实现方法：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.启动类上要有一个注解开启异
      
    
    </summary>
    
      <category term="springmvc和springboot" scheme="http://yoursite.com/categories/springmvc%E5%92%8Cspringboot/"/>
    
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>方法参数列表</title>
    <link href="http://yoursite.com/2018/07/17/java/springmvcAndSpringboot/%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/07/17/java/springmvcAndSpringboot/方法参数列表/</id>
    <published>2018-07-17T02:17:36.051Z</published>
    <updated>2018-07-17T02:17:36.052Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>1.普通方法参数<br>例如：<br>@RequestMapping(“/agreeOne”)<br>@RequiresPermissions(“withdraw:audit”)<br>@ResponseBody publicControllerResultagreeOne(Longid){ </p><blockquote><p>参数id可以不传值（可以没有这个参数{}，或者参数为空{id:null}，或者参数为空字符串id:””），方法还是会进行，当前段html或者ajax传值为””空字符串的时候，在java方法中id为null； </p></blockquote></li></ul><hr><ul><li><p>2.@RequestMapping(“/agreeOne”)<br>@RequiresPermissions(“withdraw:audit”)<br>@ResponseBody<br>Public ControllerResultagreeOne(@RequestParam Long id){ </p><blockquote><p>如果加了@RequestParam注解，则默认必须要传参，不然会报404。可以传{id:null}也可以传空字符串<br>data:{id:””}, 到了Java端参数都是null<br>但是 如果不传参数则会报404，例如：//data:{id:””},<br>或者 data:{} </p></blockquote></li></ul><hr><ul><li>3.如果变成1那种类型，则可以@RequestParam(required=false) 默认为true；和不加注解的情况一样。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.普通方法参数&lt;br&gt;例如：&lt;br&gt;@RequestMapping(“/agreeOne”)&lt;br&gt;@RequiresPermissions(“withdraw:audit”)&lt;br&gt;@ResponseBody publicControllerResul
      
    
    </summary>
    
      <category term="springmvc和springboot" scheme="http://yoursite.com/categories/springmvc%E5%92%8Cspringboot/"/>
    
    
      <category term="参数" scheme="http://yoursite.com/tags/%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/07/13/nope/"/>
    <id>http://yoursite.com/2018/07/13/nope/</id>
    <published>2018-07-13T06:51:57.960Z</published>
    <updated>2018-07-13T06:51:57.962Z</updated>
    
    <content type="html"><![CDATA[<p>傻了吧唧，谢谢</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;傻了吧唧，谢谢&lt;/p&gt;

      
    
    </summary>
    
      <category term="nope" scheme="http://yoursite.com/categories/nope/"/>
    
    
      <category term="nope" scheme="http://yoursite.com/tags/nope/"/>
    
  </entry>
  
</feed>
